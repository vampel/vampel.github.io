<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ¦‡ Vampire Deauther - Complete BW16 Flasher v9.0</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0d1117;
            color: #c9d1d9;
            line-height: 1.6;
        }
        .container { max-width: 900px; margin: 0 auto; padding: 40px 20px; }
        h1 { font-size: 2.5em; margin-bottom: 10px; color: #58a6ff; text-align: center; }
        .subtitle { text-align: center; color: #8b949e; margin-bottom: 40px; }
        .flasher-box {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 30px;
            margin-bottom: 30px;
        }
        .warning-box {
            background: #1c1416;
            border: 2px solid #f85149;
            border-radius: 6px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .info-box {
            background: #1c2128;
            border: 2px solid #58a6ff;
            border-radius: 6px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .success-box {
            background: #0f2818;
            border: 2px solid #238636;
            border-radius: 6px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .warning-box h3 { color: #f85149; margin-bottom: 10px; }
        .info-box h3 { color: #58a6ff; margin-bottom: 10px; }
        .success-box h3 { color: #3fb950; margin-bottom: 10px; }
        button {
            background: #238636;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 6px;
            cursor: pointer;
            width: 100%;
            margin: 10px 0;
            transition: background 0.2s;
        }
        button:hover { background: #2ea043; }
        button:disabled { background: #21262d; color: #484f58; cursor: not-allowed; }
        #statusBox {
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 15px;
            height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            margin: 20px 0;
        }
        #progressContainer { display: none; margin: 20px 0; }
        #progressBar {
            background: #238636;
            height: 30px;
            border-radius: 6px;
            text-align: center;
            line-height: 30px;
            color: white;
            font-weight: bold;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¦‡ Vampire Deauther</h1>
        <p class="subtitle">Complete BW16 Web Flasher v9.0 - 1.5Mbaud + 2MB Padding!</p>

        <div class="success-box">
            <h3>ğŸ”¥ v9.0 CRITICAL FIXES</h3>
            <ul style="margin-left: 20px; margin-top: 10px; line-height: 2;">
                <li><strong>âœ… Baudrate: 1,500,000</strong> (same as Arduino IDE)</li>
                <li><strong>âœ… 2MB Padding:</strong> Firmware padded with 0xFF to 2MB</li>
                <li><strong>âœ… DTR/RTS Reset:</strong> Hardware reset after flash</li>
                <li><strong>âœ… OTA2 Erase:</strong> Clears backup firmware area</li>
            </ul>
            <p style="margin-top: 10px; color: #3fb950;">ğŸ¯ This matches Arduino IDE behavior exactly!</p>
        </div>

        <div class="info-box">
            <h3>ğŸ“‹ REQUIRED FILES</h3>
            <p>Place these 4 files in the SAME folder as this HTML:</p>
            <ol style="margin-left: 20px; margin-top: 10px; line-height: 2;">
                <li><strong>imgtool_flashloader_amebad.bin</strong> (4688 bytes)</li>
                <li><strong>km0_boot_all.bin</strong> (~4.5 KB - KM0 bootloader)</li>
                <li><strong>km4_boot_all.bin</strong> (~4.5 KB - KM4 bootloader)</li>
                <li><strong>km0_km4_image2.bin</strong> (~680 KB - YOUR firmware)</li>
            </ol>
            <p style="margin-top: 10px; color: #d29922;">âš ï¸ Find these in: Arduino15\packages\realtek\tools\ameba_d_tools\1.1.3\</p>
        </div>

        <div class="warning-box">
            <h3>âš¡ Enter Bootloader Mode</h3>
            <ol style="margin-left: 20px; margin-top: 10px; line-height: 2;">
                <li><strong>Hold BURN</strong> button (~5 sec)</li>
                <li>While holding BURN, <strong>press RST</strong> (~2 sec)</li>
                <li><strong>Release RST</strong> first, then <strong>release BURN</strong></li>
                <li>Serial monitor should show: <code style="color: #79c0ff;">#</code></li>
            </ol>
        </div>

        <div class="flasher-box">
            <button id="connectBtn">Connect BW16 (1.5 Mbaud)</button>
            <button id="flashBtn" disabled>Flash Complete Firmware</button>
            
            <div id="progressContainer">
                <div id="progressBar" style="width: 0%;">0%</div>
            </div>
            
            <div id="statusBox"></div>
        </div>
    </div>

    <script>
        let port = null;
        let reader = null;
        let writer = null;

        const BAUD_RATE = 1500000; // CRITICAL: Match Arduino IDE!
        const CMD_SYNC = 0x07;
        const CMD_WRITE = 0x02;
        const CMD_RESET = 0x04;
        const CMD_ERASE = 0x17;
        const CMD_FLASH_MODE = 0x26;
        const ACK = 0x06;
        const NAK = 0x15;

        const FLASHLOADER_ADDR = 0x082000;
        const KM0_BOOT_ADDR = 0x08000000;
        const KM4_BOOT_ADDR = 0x08004000;
        const FIRMWARE_ADDR = 0x08006000;
        const OTA2_ADDR = 0x08106000;
        
        const FIRMWARE_SIZE_2MB = 0x200000; // 2MB = 2,097,152 bytes

        function log(msg, color = '#c9d1d9') {
            const statusBox = document.getElementById('statusBox');
            const time = new Date().toLocaleTimeString();
            const line = document.createElement('div');
            line.style.color = color;
            line.textContent = `[${time}] ${msg}`;
            statusBox.appendChild(line);
            statusBox.scrollTop = statusBox.scrollHeight;
        }

        function updateProgress(percent, text) {
            const container = document.getElementById('progressContainer');
            const bar = document.getElementById('progressBar');
            container.style.display = 'block';
            bar.style.width = percent + '%';
            bar.textContent = text || `${percent}%`;
        }

        async function connectSerial() {
            try {
                log('Select BW16 serial port...', '#58a6ff');
                port = await navigator.serial.requestPort();
                await port.open({ baudRate: BAUD_RATE });
                
                reader = port.readable.getReader();
                writer = port.writable.getWriter();
                
                log(`âœ… Connected to BW16 at ${BAUD_RATE} baud`, '#3fb950');
                log('Now enter bootloader mode (BURN+RST)', '#d29922');
                
                document.getElementById('connectBtn').disabled = true;
                document.getElementById('flashBtn').disabled = false;
            } catch (error) {
                log(`âŒ Connection error: ${error.message}`, '#f85149');
            }
        }

        async function readWithTimeout(timeoutMs = 1000) {
            const timeout = new Promise((_, reject) => 
                setTimeout(() => reject(new Error('Timeout')), timeoutMs)
            );
            const read = reader.read();
            return Promise.race([read, timeout]);
        }

        async function readByte() {
            const { value } = await readWithTimeout();
            return value[0];
        }

        async function flushBuffer() {
            log('Flushing initial buffer...');
            let foundNak = false;
            while (true) {
                try {
                    const byte = await readByte();
                    if (byte === NAK) {
                        foundNak = true;
                        break;
                    }
                } catch {
                    if (foundNak) break;
                    log('No initial NAK, continuing...', '#d29922');
                    break;
                }
            }
            if (foundNak) log('âœ“ Found NAK, buffer flushed', '#3fb950');
        }

        async function waitForNAKs(count = 2) {
            log(`Waiting for ${count} NAK(s)...`);
            let nakCount = 0;
            while (nakCount < count) {
                try {
                    const byte = await readByte();
                    if (byte === NAK) {
                        nakCount++;
                    } else {
                        log(`Expected 0x${NAK.toString(16)}, got 0x${byte.toString(16)}`, '#8b949e');
                    }
                } catch {
                    throw new Error('Timeout waiting for NAK');
                }
            }
            log(`âœ“ Got ${count} NAK(s)`, '#3fb950');
        }

        async function sendCommand(cmd, data = []) {
            const packet = [cmd, ...data];
            log(`â†’ CMD: 0x${cmd.toString(16)} [${packet.map(b => '0x' + b.toString(16)).join(' ')}]`, '#d29922');
            await writer.write(new Uint8Array(packet));
        }

        async function waitForACK() {
            const response = await readByte();
            if (response === ACK) {
                log('â† ACK (0x06)', '#3fb950');
                return true;
            }
            throw new Error(`Expected ACK, got 0x${response.toString(16)}`);
        }

        async function syncCommand() {
            log('Sending SYNC command...');
            await sendCommand(CMD_SYNC);
            await waitForACK();
            log('âœ“ SYNC complete', '#3fb950');
        }

        function calculateChecksum(data) {
            let sum = 0;
            for (let i = 0; i < data.length; i += 4) {
                const word = (data[i] | (data[i+1] << 8) | (data[i+2] << 16) | (data[i+3] << 24)) >>> 0;
                sum = (sum + word) >>> 0;
            }
            return sum;
        }

        async function writeBlock(addr, data) {
            const packets = Math.ceil(data.length / 1024);
            log(`Writing ${packets} packets (${data.length} bytes) to 0x${addr.toString(16)}...`);

            for (let i = 0; i < packets; i++) {
                const offset = i * 1024;
                const chunk = data.slice(offset, offset + 1024);
                const padded = new Uint8Array(1024);
                padded.set(chunk);
                
                const checksum = calculateChecksum(padded);
                const targetAddr = addr + offset;
                
                const packet = new Uint8Array(13 + 1024);
                packet[0] = CMD_WRITE;
                packet[1] = targetAddr & 0xFF;
                packet[2] = (targetAddr >> 8) & 0xFF;
                packet[3] = (targetAddr >> 16) & 0xFF;
                packet[4] = (targetAddr >> 24) & 0xFF;
                packet[5] = 0x00; packet[6] = 0x04; packet[7] = 0x00; packet[8] = 0x00;
                packet[9] = checksum & 0xFF;
                packet[10] = (checksum >> 8) & 0xFF;
                packet[11] = (checksum >> 16) & 0xFF;
                packet[12] = (checksum >> 24) & 0xFF;
                packet.set(padded, 13);

                await writer.write(packet);
                await waitForACK();
                
                updateProgress(Math.round((i + 1) / packets * 100));
            }
            
            log('âœ“ Block written successfully', '#3fb950');
        }

        async function eraseFlash(addr, blocks) {
            const packet = new Uint8Array(6);
            packet[0] = CMD_ERASE;
            packet[1] = addr & 0xFF;
            packet[2] = (addr >> 8) & 0xFF;
            packet[3] = (addr >> 16) & 0xFF;
            packet[4] = (addr >> 24) & 0xFF;
            packet[5] = blocks & 0xFF;
            
            log(`Erase 0x${addr.toString(16)} (${blocks} blocks)`);
            log(`â†’ CMD: 0x${CMD_ERASE.toString(16)} [${Array.from(packet).map(b => '0x' + b.toString(16)).join(' ')}]`, '#d29922');
            await writer.write(packet);
            await waitForACK();
        }

        function padFirmwareTo2MB(data) {
            log(`ğŸ“¦ Padding firmware from ${data.length} to ${FIRMWARE_SIZE_2MB} bytes with 0xFF`, '#58a6ff');
            const padded = new Uint8Array(FIRMWARE_SIZE_2MB);
            padded.fill(0xFF);
            padded.set(new Uint8Array(data));
            return padded;
        }

        async function loadFile(filename) {
            try {
                const response = await fetch(filename);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.arrayBuffer();
                log(`âœ“ Loaded ${filename} (${data.byteLength} bytes)`, '#3fb950');
                return data;
            } catch (error) {
                throw new Error(`Failed to load ${filename}: ${error.message}`);
            }
        }

        async function flashFirmware() {
            try {
                document.getElementById('flashBtn').disabled = true;
                updateProgress(0, 'Starting...');

                log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', '#58a6ff');
                log('ğŸ¦‡ COMPLETE FLASH START', '#58a6ff');
                log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', '#58a6ff');

                await flushBuffer();
                await waitForNAKs(2);
                await syncCommand();

                updateProgress(5, 'Loading flashloader...');
                const flashloader = await loadFile('imgtool_flashloader_amebad.bin');
                log(`Uploading flashloader (${flashloader.byteLength} bytes) to RAM 0x${FLASHLOADER_ADDR.toString(16)}...`);
                await writeBlock(FLASHLOADER_ADDR, new Uint8Array(flashloader));

                updateProgress(10, 'Resetting flashloader...');
                log('Resetting flashloader...');
                await sendCommand(CMD_RESET);
                await waitForACK();
                await waitForNAKs(2);

                updateProgress(15, 'Entering flash mode...');
                log('Entering flash programming mode...');
                await sendCommand(CMD_FLASH_MODE, [0x01, 0x01, 0x00]);
                await waitForACK();

                updateProgress(20, 'Loading files...');
                const km0Boot = new Uint8Array(await loadFile('km0_boot_all.bin'));
                const km4Boot = new Uint8Array(await loadFile('km4_boot_all.bin'));
                const firmwareRaw = await loadFile('km0_km4_image2.bin');
                
                // CRITICAL: Pad firmware to 2MB with 0xFF
                const firmware = padFirmwareTo2MB(firmwareRaw);

                updateProgress(25, 'Erasing flash...');
                log('Erasing flash blocks (this may take 30-60 seconds)...', '#d29922');
                
                await eraseFlash(KM0_BOOT_ADDR, 2);
                await eraseFlash(KM4_BOOT_ADDR, 2);
                
                const firmwareBlocks = Math.ceil(firmware.length / 4096);
                log(`âš ï¸ Erasing ${firmwareBlocks} blocks for 2MB firmware...`, '#d29922');
                await eraseFlash(FIRMWARE_ADDR, firmwareBlocks);
                
                log('âš ï¸ CRITICAL: Erasing OTA Address 2 (checked first by bootloader)...', '#f85149');
                await eraseFlash(OTA2_ADDR, firmwareBlocks);
                
                log('âœ“ Erase complete', '#3fb950');

                updateProgress(40, 'Syncing after erase...');
                log('Waiting for flashloader to be ready...');
                await new Promise(r => setTimeout(r, 1000));
                log('Sending SYNC after erase...');
                await sendCommand(CMD_SYNC);
                await waitForACK();
                await new Promise(r => setTimeout(r, 2000));

                updateProgress(45, 'Writing KM0 bootloader...');
                log('Writing KM0 bootloader to 0x000000...');
                await writeBlock(0x0, km0Boot);

                updateProgress(60, 'Writing KM4 bootloader...');
                log('Writing KM4 bootloader to 0x004000...');
                await writeBlock(0x4000, km4Boot);

                updateProgress(65, 'Writing firmware (2MB)...');
                log('Writing firmware to 0x006000 (2MB padded)...');
                await writeBlock(0x6000, firmware);

                updateProgress(95, 'Performing hardware reset...');
                log('Performing hardware reset via DTR/RTS...', '#d29922');
                await sendCommand(CMD_RESET);
                await waitForACK();
                
                // Hardware reset sequence
                await port.setSignals({ dataTerminalReady: false, requestToSend: false });
                await new Promise(r => setTimeout(r, 100));
                await port.setSignals({ dataTerminalReady: true, requestToSend: true });
                
                updateProgress(100, 'âœ… COMPLETE!');
                
                log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', '#3fb950');
                log('âœ… FLASH SUCCESSFUL!', '#3fb950');
                log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', '#3fb950');
                log('Device should auto-boot into firmware now!', '#3fb950');

            } catch (error) {
                log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', '#f85149');
                log(`âŒ FLASH FAILED: ${error.message}`, '#f85149');
                log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', '#f85149');
                updateProgress(0, 'Failed');
                document.getElementById('progressContainer').style.display = 'none';
                throw error;
            } finally {
                try {
                    if (reader) { reader.releaseLock(); reader = null; }
                    if (writer) { writer.releaseLock(); writer = null; }
                    if (port) { await port.close(); port = null; }
                } catch {}
                document.getElementById('connectBtn').disabled = false;
                document.getElementById('flashBtn').disabled = true;
            }
        }

        document.getElementById('connectBtn').addEventListener('click', connectSerial);
        document.getElementById('flashBtn').addEventListener('click', flashFirmware);

        log('[INFO] Complete BW16 Web Flasher v9.0', '#58a6ff');
        log('[INFO] CRITICAL: 1.5Mbaud + 2MB padding (matches Arduino IDE)', '#3fb950');
        log('[INFO] Ready. Click "Connect BW16" to begin.', '#c9d1d9');
    </script>
</body>
</html>