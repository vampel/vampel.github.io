<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ðŸ¦‡ Vampire Deauther - BW16 Web Flasher v31.1</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0d1117;
            color: #c9d1d9;
            line-height: 1.6;
        }
        .container { max-width: 900px; margin: 0 auto; padding: 40px 20px; }
        h1 { font-size: 2.5em; margin-bottom: 10px; color: #58a6ff; text-align: center; }
        .subtitle { text-align: center; color: #8b949e; margin-bottom: 40px; }
        .flasher-box {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 30px;
            margin-bottom: 30px;
        }
        .warning-box {
            background: #1c1416;
            border: 2px solid #f85149;
            border-radius: 6px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .info-box {
            background: #1c2128;
            border: 2px solid #58a6ff;
            border-radius: 6px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .success-box {
            background: #0f2818;
            border: 2px solid #238636;
            border-radius: 6px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .warning-box h3 { color: #f85149; margin-bottom: 10px; }
        .info-box h3 { color: #58a6ff; margin-bottom: 10px; }
        .success-box h3 { color: #3fb950; margin-bottom: 10px; }
        .downloads-section {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 20px;
            margin-bottom: 30px;
            text-align: center;
        }
        .downloads-section h3 { 
            color: #58a6ff; 
            margin-bottom: 15px; 
        }
        button {
            background: #238636;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 6px;
            cursor: pointer;
            width: 100%;
            margin: 10px 0;
            transition: background 0.2s;
        }
        button:hover { background: #2ea043; }
        button:disabled { background: #21262d; color: #484f58; cursor: not-allowed; }
        .download-link {
            display: inline-block;
            background: #1f6feb;
            color: white;
            padding: 10px 20px;
            border-radius: 6px;
            text-decoration: none;
            margin: 5px;
            transition: background 0.2s;
        }
        .download-link:hover { background: #388bfd; }
        #statusBox {
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 15px;
            height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            margin: 20px 0;
        }
        #progressContainer { display: none; margin: 20px 0; }
        #progressBar {
            background: #238636;
            height: 30px;
            border-radius: 6px;
            text-align: center;
            line-height: 30px;
            color: white;
            font-weight: bold;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ¦‡ Vampire Deauther</h1>
        <p class="subtitle">Complete BW16 Web Flasher v31.1</p>

        <div class="downloads-section">
            <h3>ðŸ“¥ Downloads</h3>
            <a href="./vampire_deauther.fap" class="download-link" download>
                ðŸ“¦ Download Flipper FAP
            </a>
            <a href="https://github.com/Vampel/Vampire-Deauther" class="download-link" target="_blank">
                ðŸ¦‡ View on GitHub
            </a>
        </div>

        <div class="flasher-box">
            <h3 style="color: #58a6ff; margin-bottom: 15px;">ðŸš€ Flash BW16 Firmware</h3>
            
            <button id="connectBtn">Connect BW16 (115200 baud)</button>
            <button id="flashBtn" disabled>Flash Complete Firmware (2MB)</button>
            
            <div id="progressContainer">
                <div id="progressBar" style="width: 0%;">0%</div>
            </div>
            
            <div id="statusBox"></div>
        </div>

        <div class="warning-box">
            <h3>âš¡ Enter Bootloader Mode (IMPORTANT!)</h3>
            <p><strong>Correct sequence to see "#Flash Download Start":</strong></p>
            <ol style="margin-left: 20px; margin-top: 10px; line-height: 2;">
                <li><strong>Hold BURN</strong> button (keep holding ~5 seconds)</li>
                <li>While holding BURN, <strong>press RST</strong> button</li>
                <li><strong>Release RST</strong> first</li>
                <li><strong>Then release BURN</strong></li>
                <li>You should see: <code style="color: #79c0ff;">#Flash Download Start</code></li>
            </ol>
            <p style="margin-top: 10px; color: #d29922;">ðŸ’¡ After entering bootloader, click "Flash Complete Firmware" above!</p>
        </div>
    </div>

    <script>
// ============================================================================
// BW16 WEB FLASHER v31.1 - SINGLE BLOB FLASH
// ============================================================================
// Auto-loads BW16_vampel.bin from GitHub and flashes complete 2MB firmware
// Based on SharpRTL872xTool methodology - confirmed working addresses
// ============================================================================

const BAUDRATE_INIT = 115200;
const BAUDRATE_FLASH = 1500000;
const TIMEOUT_MS = 10000; // 10 seconds like rtltool

// Commands
const CMD_SYNC = 0x07;
const CMD_RESET = 0x04;
const CMD_WRITE = 0x02;
const CMD_WRITE_HEADER = 0x27;
const ACK = 0x06;
const NAK = 0x15;

// Flash addresses - CONFIRMED from dump analysis
const FLASH_OFFSET = 0x00000000; // Single blob starts at 0

let port = null;
let reader = null;
let writer = null;
let firmwareData = null;

// ============================================================================
// LOGGING
// ============================================================================

function log(msg, color = '#c9d1d9') {
    const statusBox = document.getElementById('statusBox');
    const time = new Date().toLocaleTimeString();
    const line = document.createElement('div');
    line.style.color = color;
    line.textContent = `[${time}] ${msg}`;
    statusBox.appendChild(line);
    statusBox.scrollTop = statusBox.scrollHeight;
}

function updateProgress(percent, text) {
    const container = document.getElementById('progressContainer');
    const bar = document.getElementById('progressBar');
    container.style.display = 'block';
    bar.style.width = percent + '%';
    bar.textContent = text || `${percent}%`;
}

function hideProgress() {
    document.getElementById('progressContainer').style.display = 'none';
}

// ============================================================================
// AUTO-LOAD FIRMWARE FROM GITHUB
// ============================================================================

async function loadFirmwareFromGitHub() {
    try {
        log('[INFO] Loading BW16_vampel.bin...', '#58a6ff');
        
        const response = await fetch('./BW16_vampel.bin');
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        firmwareData = new Uint8Array(await response.arrayBuffer());
        
        const sizeMB = (firmwareData.length / 1024 / 1024).toFixed(2);
        log(`[INFO] âœ… Firmware loaded: ${firmwareData.length.toLocaleString()} bytes (${sizeMB} MB)`, '#3fb950');
        
        if (firmwareData.length !== 2097152) {
            log(`[WARN] âš ï¸  Expected 2.00 MB, got ${sizeMB} MB`, '#d29922');
        }
        
        return true;
        
    } catch (error) {
        log(`[ERROR] âŒ Failed to load firmware: ${error.message}`, '#f85149');
        log('[ERROR] Make sure BW16_vampel.bin is in the same directory as index.html', '#f85149');
        return false;
    }
}

// ============================================================================
// SERIAL COMMUNICATION
// ============================================================================

async function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

async function readBytes(count, timeoutMs = TIMEOUT_MS) {
    const buffer = [];
    const startTime = Date.now();
    
    while (buffer.length < count) {
        if (Date.now() - startTime > timeoutMs) {
            throw new Error(`Timeout reading ${count} bytes (got ${buffer.length})`);
        }
        
        const { value, done } = await reader.read();
        if (done) throw new Error('Stream closed');
        
        buffer.push(...value);
    }
    
    return new Uint8Array(buffer.slice(0, count));
}

async function readUntilACK(timeoutMs = TIMEOUT_MS) {
    const startTime = Date.now();
    const buffer = [];
    let byteCount = 0;
    
    while (Date.now() - startTime < timeoutMs) {
        try {
            const { value, done } = await reader.read();
            if (done) throw new Error('Stream closed');
            
            for (const byte of value) {
                buffer.push(byte);
                byteCount++;
                if (byte === ACK) {
                    return true;
                }
                // Log NAKs
                if (byte === NAK) {
                    log(`[DEBUG] Received NAK (byte ${byteCount})`, '#d29922');
                }
            }
            
            // Log every 100 bytes received without ACK
            if (byteCount > 0 && byteCount % 100 === 0) {
                log(`[DEBUG] Waiting for ACK... (${byteCount} bytes received)`, '#8b949e');
            }
        } catch (e) {
            // Continue waiting
        }
    }
    
    // Show what we got if timeout
    const hexBytes = buffer.slice(0, 20).map(b => b.toString(16).padStart(2, '0')).join(' ');
    log(`[DEBUG] Timeout! Got ${buffer.length} bytes: ${hexBytes}...`, '#f85149');
    throw new Error(`Timeout waiting for ACK (got ${buffer.length} bytes)`);
}

async function sendCommand(cmd) {
    await writer.write(new Uint8Array([cmd]));
}

async function sendSync() {
    await sendCommand(CMD_SYNC);
    await readUntilACK();
}

async function flushBuffer(timeoutMs = 1000) {
    const startTime = Date.now();
    let totalBytes = 0;
    
    while (Date.now() - startTime < timeoutMs) {
        try {
            // Try to read with a very short timeout
            const readPromise = reader.read();
            const timeoutPromise = new Promise((_, reject) => 
                setTimeout(() => reject(new Error('flush timeout')), 100)
            );
            
            const result = await Promise.race([readPromise, timeoutPromise]);
            
            if (result.value && result.value.length > 0) {
                totalBytes += result.value.length;
            } else {
                // No more data available
                break;
            }
        } catch (e) {
            // Timeout or no data - that's OK
            break;
        }
    }
    
    return totalBytes;
}

// ============================================================================
// XMODEM PROTOCOL
// ============================================================================

async function writeFlashPacket(sequence, offset, data) {
    const packetSize = data.length;
    const packet = new Uint8Array(3 + 4 + packetSize + 1);
    
    // Header
    packet[0] = packetSize === 1024 ? 0x02 : 0x01; // STX or SOH
    packet[1] = sequence & 0xFF;
    packet[2] = (~sequence) & 0xFF;
    
    // Offset (4 bytes, little-endian)
    packet[3] = (offset) & 0xFF;
    packet[4] = (offset >> 8) & 0xFF;
    packet[5] = (offset >> 16) & 0xFF;
    packet[6] = (offset >> 24) & 0xFF;
    
    // Data
    packet.set(data, 7);
    
    // Checksum
    let sum = 0;
    for (let i = 0; i < packetSize; i++) {
        sum = (sum + data[i]) & 0xFF;
    }
    packet[7 + packetSize] = sum;
    
    // Send packet
    await writer.write(packet);
    
    // Wait for ACK
    await readUntilACK();
}

// ============================================================================
// FLASH PROCESS
// ============================================================================

async function loadFlashloader() {
    log('[INFO] Loading flashloader...', '#58a6ff');
    
    const response = await fetch('./imgtool_flashloader_amebad.bin');
    if (!response.ok) {
        throw new Error(`Error loading flashloader: ${response.status}`);
    }
    
    const flashloader = new Uint8Array(await response.arrayBuffer());
    log(`[INFO] âœ… Flashloader loaded: ${flashloader.length} bytes`, '#3fb950');
    
    return flashloader;
}

async function uploadFlashloaderToRAM(flashloader) {
    const ramAddress = 0x82000;
    const length = flashloader.length;
    
    log(`[INFO] Uploading flashloader to RAM (0x${ramAddress.toString(16).toUpperCase()})...`, '#58a6ff');
    
    // Send WRITE_HEADER
    const header = new Uint8Array(9);
    header[0] = CMD_WRITE_HEADER;
    header[1] = (ramAddress) & 0xFF;
    header[2] = (ramAddress >> 8) & 0xFF;
    header[3] = (ramAddress >> 16) & 0xFF;
    header[4] = (ramAddress >> 24) & 0xFF;
    header[5] = (length) & 0xFF;
    header[6] = (length >> 8) & 0xFF;
    header[7] = (length >> 16) & 0xFF;
    header[8] = (length >> 24) & 0xFF;
    
    await writer.write(header);
    const response = await readBytes(1);
    
    if (response[0] !== NAK) {
        throw new Error(`Expected NAK, got 0x${response[0].toString(16)}`);
    }
    
    // Send data packets
    const numPackets = Math.ceil(length / 1024);
    let sequence = 1;
    
    for (let i = 0; i < numPackets; i++) {
        const start = i * 1024;
        const end = Math.min(start + 1024, length);
        const chunk = flashloader.slice(start, end);
        
        // Pad last packet to 1024 if needed
        const paddedChunk = new Uint8Array(1024);
        paddedChunk.set(chunk);
        paddedChunk.fill(0xFF, chunk.length);
        
        await writeFlashPacket(sequence++, 0, paddedChunk);
    }
    
    log(`[INFO] âœ… Flashloader uploaded (${numPackets} packets)`, '#3fb950');
}

async function flashFirmware() {
    const totalSize = firmwareData.length;
    const numPackets = Math.ceil(totalSize / 1024);
    let sequence = 1;
    
    log(`[INFO] Flashing firmware (${(totalSize/1024/1024).toFixed(2)} MB, ${numPackets} packets)...`, '#58a6ff');
    
    for (let i = 0; i < numPackets; i++) {
        const start = i * 1024;
        const end = Math.min(start + 1024, totalSize);
        const chunk = firmwareData.slice(start, end);
        const offset = start; // Relative offset from 0
        
        // Pad last packet to 1024 if needed
        const paddedChunk = new Uint8Array(1024);
        paddedChunk.set(chunk);
        paddedChunk.fill(0xFF, chunk.length);
        
        // Build XMODEM packet: [STX/SOH][SEQ][~SEQ][ADDR:4][DATA:1024][CHECKSUM]
        const packet = new Uint8Array(3 + 4 + 1024 + 1);
        
        // Header
        packet[0] = 0x02; // STX (1024 bytes)
        packet[1] = sequence & 0xFF;
        packet[2] = (~sequence) & 0xFF;
        
        // Offset (4 bytes, little-endian)
        packet[3] = (offset) & 0xFF;
        packet[4] = (offset >> 8) & 0xFF;
        packet[5] = (offset >> 16) & 0xFF;
        packet[6] = (offset >> 24) & 0xFF;
        
        // Data
        packet.set(paddedChunk, 7);
        
        // Checksum
        let sum = 0;
        for (let j = 0; j < 1024; j++) {
            sum = (sum + paddedChunk[j]) & 0xFF;
        }
        packet[1031] = sum;
        
        // Send packet
        await writer.write(packet);
        
        // Wait for ACK
        await readUntilACK();
        
        sequence++;
        
        // Update progress
        const percent = ((i + 1) / numPackets) * 100;
        updateProgress(percent);
        
        // Log every 100 packets
        if ((i + 1) % 100 === 0 || i === numPackets - 1) {
            log(`[INFO]   Packet ${i + 1}/${numPackets} (${percent.toFixed(1)}%)`, '#c9d1d9');
        }
    }
    
    hideProgress();
    log('[INFO] âœ… Firmware flashed successfully!', '#3fb950');
}

async function performFlash() {
    try {
        log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', '#58a6ff');
        log('ðŸ¦‡ COMPLETE FLASH START', '#58a6ff');
        log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', '#58a6ff');
        
        // Phase 1: ROM Bootloader @ 115200
        log('', '#c9d1d9');
        log('â”€â”€â”€ PHASE 1: ROM BOOTLOADER @ 115200 â”€â”€â”€', '#58a6ff');
        
        await delay(100);
        const flushed = await flushBuffer();
        log(`[INFO] Flushed ${flushed} bytes from buffer`, '#c9d1d9');
        
        log('[INFO] Sending SYNC to ROM...', '#c9d1d9');
        await sendSync();
        log('[INFO] âœ“ SYNC complete', '#3fb950');
        
        // Upload flashloader
        const flashloader = await loadFlashloader();
        await uploadFlashloaderToRAM(flashloader);
        
        // Flashloader auto-executes and enters XMODEM receive mode
        log('[INFO] Flashloader running in XMODEM mode @ 115200', '#c9d1d9');
        
        // Small delay for flashloader to be ready
        await delay(300);
        
        // Phase 2: Flash firmware at 115200 baud
        log('', '#c9d1d9');
        log('â”€â”€â”€ PHASE 2: FLASH FIRMWARE @ 115200 â”€â”€â”€', '#58a6ff');
        log('[INFO] Flashing at 115200 baud (slower but stable)...', '#c9d1d9');
        
        await flashFirmware();
        
        // Done!
        log('', '#c9d1d9');
        log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', '#3fb950');
        log('ðŸŽ‰ FLASH COMPLETE!', '#3fb950');
        log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', '#3fb950');
        log('Reset your BW16 to use the new firmware', '#3fb950');
        
    } catch (error) {
        hideProgress();
        log('', '#c9d1d9');
        log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', '#f85149');
        log('âŒ FLASH FAILED', '#f85149');
        log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', '#f85149');
        log(`[ERROR] ${error.message}`, '#f85149');
        if (error.stack) {
            log(`[ERROR] ${error.stack}`, '#f85149');
        }
        throw error;
    }
}

// ============================================================================
// BUTTON HANDLERS
// ============================================================================

document.getElementById('connectBtn').addEventListener('click', async () => {
    try {
        if (port) {
            // Disconnect
            if (reader) await reader.releaseLock();
            if (writer) await writer.releaseLock();
            await port.close();
            
            port = null;
            reader = null;
            writer = null;
            
            document.getElementById('connectBtn').textContent = 'Connect BW16 (115200 baud)';
            document.getElementById('flashBtn').disabled = true;
            
            log('[WARN] Disconnected from BW16', '#d29922');
            
        } else {
            // Connect
            log('Select BW16 serial port...', '#58a6ff');
            
            port = await navigator.serial.requestPort();
            await port.open({ baudRate: BAUDRATE_INIT });
            
            reader = port.readable.getReader();
            writer = port.writable.getWriter();
            
            document.getElementById('connectBtn').textContent = 'Disconnect';
            
            log(`[INFO] âœ… Connected to BW16 at ${BAUDRATE_INIT} baud`, '#3fb950');
            log('[INFO] Now enter bootloader mode (BURN+RST)', '#d29922');
            
            // Enable flash button if firmware is loaded
            if (firmwareData) {
                document.getElementById('flashBtn').disabled = false;
                log('[INFO] Ready to flash!', '#3fb950');
            } else {
                log('[WARN] Waiting for firmware to load...', '#d29922');
            }
        }
        
    } catch (error) {
        log(`[ERROR] âŒ Connection error: ${error.message}`, '#f85149');
    }
});

document.getElementById('flashBtn').addEventListener('click', async () => {
    try {
        document.getElementById('flashBtn').disabled = true;
        document.getElementById('connectBtn').disabled = true;
        
        await performFlash();
        
    } catch (error) {
        log('[ERROR] Flash failed. Check connection and try again.', '#f85149');
        
    } finally {
        document.getElementById('flashBtn').disabled = false;
        document.getElementById('connectBtn').disabled = false;
    }
});

// ============================================================================
// STARTUP - AUTO-LOAD FIRMWARE
// ============================================================================

log('[INFO] Complete BW16 Web Flasher v31.1 FINAL', '#58a6ff');
log('[INFO] Single blob flash method (2MB)', '#3fb950');
log('[INFO] Auto-loading firmware...', '#c9d1d9');

loadFirmwareFromGitHub().then(success => {
    if (success) {
        log('[INFO] Ready to flash! Connect your BW16 to begin.', '#3fb950');
        
        // Enable flash button if already connected
        if (port && reader && writer) {
            document.getElementById('flashBtn').disabled = false;
            log('[INFO] Flash button enabled!', '#3fb950');
        }
    } else {
        log('[ERROR] Failed to load firmware. Cannot proceed.', '#f85149');
    }
});

    </script>
</body>
</html>